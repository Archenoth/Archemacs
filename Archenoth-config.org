#+TITLE:My Emacs config
#+AUTHOR:Archenoth
:SETTINGS:
#+STARTUP: hidestars
#+OPTIONS: tags:not-in-toc todo:nil toc:nil
#+TAGS: Bindings(b) Hooks(h) Functions(f) Advice(a)
#+PROPERTY: header-args :results silent :exports both :eval never-export
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+DRAWERS: SETTINGS
#+LATEX_HEADER: \usepackage{parskip}
#+TOC: headlines 3
#+LATEX: \pagebreak
:END:

It's pretty sweet you can use [[info:org#Working with source code][literate programming as configuration]]
for something that often has a lot of configuration.

Below is my Emacs configuration along with descriptions of what each
piece does:

* Header
In the header of the config... We want the file to include lexical
binding... This is because I am quite accustomed to a Common-Lisp
style of developing with =let= closures and have-at-you:
#+BEGIN_SRC emacs-lisp :eval no :padline no
  ;; -*- lexical-binding: t -*-
#+END_SRC

Also, I include this library to make up for some of the other missing
features from Common Lisp:
#+BEGIN_SRC emacs-lisp
  ;; For other Common Lisp-ish stuff in here
  (require 'cl-lib)
#+END_SRC


* Setting up the package manager
The package manager in Emacs is pretty sweet, but the default repos
are quite limited in their selection of packages... So instead, I add
a couple more repos. (I am sure almost everyone has this in their
configuration somewhere)
#+BEGIN_SRC emacs-lisp
  ;; Package Manager URLs
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
               ("marmalade" . "http://marmalade-repo.org/packages/")
               ("melpa" . "http://melpa.milkbox.net/packages/")
               ("org" . "http://orgmode.org/elpa/")))
#+END_SRC

Then, we want to require TLS... This is for =erc-tls=, yes, but I
believe it will also be used for all other pieces of Emacs that use
SSL. (Like the package manager eventually, hence its location in the
config file.)
#+BEGIN_SRC emacs-lisp
  ;; SSL Support (For ERC primarily)
  (require 'tls)
#+END_SRC

And then we initialize the package manager, anything past this line
has the entirety of the installed packages available:
#+BEGIN_SRC emacs-lisp
  ;; Just in case
  (package-initialize)
#+END_SRC

** Package checker and installer                                  :Functions:
What about if there are no packages? Or some are missing?

I wrote a little package checker and installer so that I would not
have to worry about manually installing packages I like to have by
default:
#+BEGIN_SRC emacs-lisp
  ;; My little package checker and installer
  (defun check-packages (&rest packages)
    "Checks if the passed in packages are installed, and installs
  the ones that are not."
    (cl-loop for package in packages
             with refreshed = nil
             unless (package-installed-p package)
               unless refreshed
                 do (package-refresh-contents)
                 and do (setq refreshed t)
               end
             and do (package-install package)))
#+END_SRC

Now, lets use this to install all the packages we need if they don't
exist already:
#+BEGIN_SRC emacs-lisp
  ;; Ensuring packages are installed
  (check-packages 'multiple-cursors 'web-mode 'slime 'rsense 'robe
   'projectile 'powerline 'plsql 'php-mode 'paredit 'nurumacs
   'yasnippet 'markdown-mode+ 'magit 'lua-mode 'langtool
   'js2-refactor 'jedi 'htmlize 'helm-projectile 'helm-emmet
   'grizzl 'graphviz-dot-mode 'flymake-ruby 'flymake-jshint
   'flymake-easy 'flymake-csslint 'feature-mode 'expand-region
   'evil 'erefactor 'erc-nick-notify 'enh-ruby-mode 'emmet-mode
   'ecukes 'cucumber-goto-step 'cider 'firebelly-theme 'apache-mode
   'avy 'ac-slime 'ac-js2 'ac-emmet 'edbi-minor-mode
   'firecode-theme 'sauron 'tern-auto-complete)
#+END_SRC


* Convenience functions
Sometimes, its nice to have a few functions to make my configuration
easier and more modular... That is the purpose of this section.

** Path file checker                                              :Functions:
This is a function I wrote to check to see if there is any file in the
current path that matches the passed in filename... The purpose behind
this was to be able to check if there are binaries that Emacs can use
for particular functionality... (Like [[JavaScript][Tern]] for example; I would only
want to enable its functionality if a "=tern=" binary existed
somewhere on the system):
#+BEGIN_SRC emacs-lisp
  (defun exec-exists-p (filename)
    "Checks to see if Emacs can see a file in the execution path.

  Returns \"t\" if the passed in filename exists in any of the
  executable search directories (\"exec-path\"). Returns \"nil\"
  otherwise."
    (cl-reduce (lambda (exists dir)
                 (or exists (file-exists-p (concat dir "/" filename))))
               exec-path :initial-value nil))
#+END_SRC


* Style options
I don't care too much for the default appearance of Emacs... I
generally like to remove the toolbar at the top of the screen:

#+BEGIN_SRC emacs-lisp
  ;; Remove unsightly toolbar...
  (tool-bar-mode 0)
#+END_SRC

And remove fringes when in a windowed mode... And since that is the
default when we start up Emacs:

#+BEGIN_SRC emacs-lisp
  ;; ...and fringes until we want to explicitly enable them
  (when (fboundp 'fringe-mode)
    (fringe-mode 0))
#+END_SRC

As for in-depth styling, I generally like to switch between two
different appearances depending on whether or not Emacs is fullscreen
or not.

** Fullscreen style
The defaults for fullscreen are:
#+BEGIN_SRC emacs-lisp
  (setq fullscreen-faces
        (if (boundp 'fullscreen-theme)
            fullscreen-theme
          '((fringe ((t (:background "#111" :width expanded))))
            (linum ((t (:inherit (shadow default)
                                 :background "#111"
                                 :foreground "#e0e0e0"))) t)
            (pe/directory-face ((t (:inherit dired-directory
                                             :weight normal
                                             :height 0.9))) t)
            (pe/file-face ((t (:inherit default
                                        :background "#111"
                                        :weight normal
                                        :height 0.9))) t))))
#+END_SRC

This essentially is just a minimal set of sane defaults for
fullscreen, though if the variable =fullscreen-theme= is set, those
faces will be used instead of the default.

Of course, we need some way to apply it. The following is the
definition for the function that will handle the logic for what
happens when we switch from windowed to fullscreen:
#+BEGIN_SRC emacs-lisp
  (defun set-fullscreen-theme ()
    "Sets the default theme I use for maximixed Emacs"
    (interactive)
    (enable-theme 'firecode)
    (disable-theme 'firebelly)
    (apply #'custom-set-faces fullscreen-faces)
    (fringe-mode '(20 . 0))
    (scroll-bar-mode -1)
    (menu-bar-mode -1))
#+END_SRC

Now for windowed!

** Windowed style
These are the default faces for windowed Emacs windows.

As you can see, if there is a =windowed-theme= variable set before
this file is initialized, this will use that as opposed to the
defaults below.

That way we don't need to dig into this config file to change it.
#+BEGIN_SRC emacs-lisp
  (setq windowed-faces
        (if (boundp 'windowed-theme)
            windowed-theme
          '((scroll-bar ((t nil)))
            (font-lock-function-name-face ((t (:foreground "#fff"))))
            (font-lock-variable-name-face ((t (:foreground "#ddd"))))
            (font-lock-comment-face ((t (:foreground "steel blue"))))
            (vertical-border ((nil (:foreground "#191919"))))
            (font-lock-comment-delimiter-face
             ((t (:inherit font-lock-comment-face :foreground "steel blue")))))))
#+END_SRC

Since switching to windowed mode has some strange results with frame
sizing, here is a function that can restore the size back to the
normal windowed state:
#+BEGIN_SRC emacs-lisp
  (defun set-default-window-size ()
    "Sets the default window size..."
    (interactive)
    (modify-frame-parameters
     (selected-frame)
     '((width . 80) (height . 34))))
#+END_SRC

And now, just like in [[Fullscreen style]], here is the function that gets
called to handle switching from fullscreen to windowed:

#+BEGIN_SRC emacs-lisp
  (defun set-window-theme ()
    "Sets the default theme I use for Windowed Emacs"
    (interactive)
    (enable-theme 'firebelly)
    (disable-theme 'firecode)
    (apply #'custom-set-faces windowed-faces)
    (fringe-mode 0)
    (scroll-bar-mode 1)
    (menu-bar-mode 1)
    (set-default-window-size))
#+END_SRC

Spifftastic! Now time to put it all together...

** The actual style logic                         :Bindings:Functions:Advice:
As for whether to apply these themes, it is all dependant on whether
or not we are running in NOX:

The general idea behind this style logic is that it will only exist
when we have a graphical version of Emacs running... It will also keep
track of whether or not we are in fullscreen in a little =let=
closure:
#+BEGIN_SRC emacs-lisp :noweb yes
  ;; Firebelly and firecode themes, fullscreen, and powerline... Bad in
  ;; NOX though.
  (when (display-graphic-p)
    (let ((is-fullscreen nil))
      <<toggle-fullscreen>>

      <<display-buffer-advice>>)

    <<toggle-style-initialization>>)
#+END_SRC

What we want here is something that allows me to toggle between two
style configurations, one for fullscreen mode, the other for windowed
with the [F11] key.

I also want a piece of advice for =display-buffer= to prefer to not
create new windows when in fullscreen mode.

For the "=<<toggle-fullscreen>>=" above, we create a function that
will interactively toggle between two modes, fullscreen and not:
#+NAME:toggle-fullscreen
#+BEGIN_SRC emacs-lisp :eval no :tangle no
  (defun toggle-fullscreen ()
    "Toggles fullscreen emacs"
    (interactive)
    (if is-fullscreen
        (progn
          (set-frame-parameter nil 'fullscreen nil)
          (setq is-fullscreen nil)
          (set-window-theme))
      (progn
        (set-frame-parameter nil 'fullscreen 'fullboth)
        (setq is-fullscreen t)
        (set-fullscreen-theme))))
#+END_SRC

When switching to a mode, the frame parameters are changed, the
lexical =is-fullscreen= variable is set to the correct value, and the
correct theme defined above is chosen.

After that, in "=<<display-buffer-advice>>=", I have created a
function that can act as "=:filter-args=" advice. It will, when the
=is-fullscreen= variable is set, make sure the =action= parameter is
not set to "=t=" when calling =display-buffer=, because that will pop
up a new window:
#+NAME:display-buffer-advice
#+BEGIN_SRC emacs-lisp :tangle no :eval no
  (defun my-display-buffer (args)
    (cl-destructuring-bind (buffer-or-name &optional action frame) args
      (let ((action (unless (and is-fullscreen (null frame) (eq action t)) action)))
        (list buffer-or-name action frame))))
#+END_SRC

This, of course, doesn't stop explicit actions from creating new
windows, but it deters a lot of the defaults that drive me up the
wall. (Like popping up a new window for Code blocks and for Org
menus.)

Now, of course, here is the initialization code I have at
"=<<toggle-style-initialization>>=":
#+NAME:toggle-style-initialization
#+BEGIN_SRC emacs-lisp :tangle no :eval no
  (advice-add 'display-buffer :filter-args #'my-display-buffer)

  ;; Load both themes for later
  (load-theme 'firecode t t)
  (load-theme 'firebelly t t)

  (powerline-center-theme)
  (set-window-theme)
  (global-set-key (kbd "<f11>") 'toggle-fullscreen)
#+END_SRC

This just adds the advice defined above, loads the themes for each
screen mode, loads =powerline=, sets the [[Windowed style][windowed theme]], and binds
=<f11>= to the toggle function.

That's about the extent of my style logic. Nothing too scary.


* Languages                                                           :Hooks:
The following are package-loaded language support configurations:

** Language agonistic
This section is all about the setup that is about programming, but not
for a particular language.

*** Flymake
Of course, there are a few modes that I like to have Flymake.
enabled on by default...
#+BEGIN_SRC emacs-lisp :eval no
  ;; Flymake
#+END_SRC

Of those, we have =perl-mode=:
#+BEGIN_SRC emacs-lisp :padline no
  (add-hook 'perl-mode-hook (lambda () (flymake-mode t)))
#+END_SRC

And =php-mode=:
#+BEGIN_SRC emacs-lisp :padline no
  (add-hook 'php-mode-hook (lambda () (flymake-mode t)))
#+END_SRC

*** Autocomplete
Autocomplete is magnificent. I will have it enabled for almost every
programming mode in existence.

#+BEGIN_SRC emacs-lisp
  (ac-config-default)
#+END_SRC

*** Compile                                                        :Bindings:
I generally like having a compile command as [F5]:
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "<f5>") 'compile)
#+END_SRC

No, compiling is not always relevant to all languages, but it doubles
as a quick command-line, which is almost always useful.

** C and C++                                                       :Bindings:
Emacs' [[info:Semantic][Semantic]] mode is really good at C... I have not tested it
extensively with C++ though.

But with it, we get definition jumping and some quite intelligent
=autocomplete=... So I simply define the jumping keybinding, the
=autocomplete= sources, and add it to both C and C++ modes as hooks:

#+BEGIN_SRC emacs-lisp
  ;; C and C++
  (defun c-modes-hook ()
    (semantic-mode)
    (local-set-key (kbd "s-<f3>") #'semantic-ia-fast-jump)
    (semantic-idle-summary-mode 1)
    (setq ac-sources '(ac-source-semantic-raw
               ac-source-yasnippet)))
  (add-hook 'c-mode-hook 'c-modes-hook)
  (add-hook 'c++-mode-hook 'c-modes-hook)
#+END_SRC

** Clojure
All I do for Clojure is turn on =eldoc-mode=. The rest is handled by
CIDER:


#+BEGIN_SRC emacs-lisp
  ;; CIDER, Clojure
  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
#+END_SRC

** Common Lisp
The Common Lisp setup is largely just setting up Slime and Slime's
=autocomplete= source according to [[https://github.com/slime/slime][their Github page]].
#+BEGIN_SRC emacs-lisp
  ;; Common Lisp
  ;; Set your lisp system and, optionally, some contribs Common Lisp
  (setq slime-contribs '(slime-fancy slime-asdf))
  (add-hook 'slime-mode-hook 'set-up-slime-ac)
  (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
  (add-to-list 'ac-modes 'slime-repl-mode)
#+END_SRC

Nothing really special here.

** ELISP                                                           :Bindings:
#+BEGIN_SRC emacs-lisp :eval no
  ;; ELISP
#+END_SRC
My ELISP configuration is largely just setting up =erefactor= and then
adding it to the three ELISP modes.

So first I require the package:
#+BEGIN_SRC emacs-lisp
  (require 'erefactor)
#+END_SRC

Then I define a hook that turns on =erefactor='s scope highlighting,
=eldoc-mode=, and defines a key for to start refactoring:

#+BEGIN_SRC emacs-lisp
  ;; Hook for all ELISP modes
  (defun el-hook ()
    (define-key emacs-lisp-mode-map "\C-c\C-v" erefactor-map)
    (erefactor-lazy-highlight-turn-on)
    (eldoc-mode t))
#+END_SRC

Then I simply assign the function as a hook for all of the ELISP
modes:
#+BEGIN_SRC emacs-lisp
  ;; And assigning to said modes
  (add-hook 'emacs-lisp-mode-hook 'el-hook)
  (add-hook 'lisp-interaction-mode-hook 'el-hook)
  (add-hook 'ielm-mode-hook 'el-hook)
#+END_SRC

** Feature                                                         :Bindings:
#+BEGIN_SRC emacs-lisp :eval no
  ;; Feature mode
#+END_SRC

Since I work with [[https://cucumber.io/][Cucumber]] feature files reasonably often, I find it
useful to be able to jump right to the definition of some Cucumber
step I am looking at. I also like Slime's evaluation bindings, so I
emulate those here:
#+BEGIN_SRC emacs-lisp :padline no
  (add-hook 'feature-mode-hook
            (lambda ()
              (local-set-key (kbd "C-c C-c") 'feature-verify-scenario-at-pos)
              (local-set-key (kbd "C-c C-k") 'feature-verify-all-scenarios-in-buffer)
              (local-set-key (kbd "<f5>") 'feature-verify-all-scenarios-in-project)
              (local-set-key (kbd "s-<f3>") 'jump-to-cucumber-step)))
#+END_SRC

** HTML, JSP, PHP, and so on...
For most markup-centric web development, I start up =web-mode=:

#+BEGIN_SRC emacs-lisp
  ;; Web Mode for HTML, JSPs, etc...
  (add-to-list 'auto-mode-alist '("\\.[sj]?html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.phtml$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php[34]?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.ejs$" . web-mode))
  (setq web-mode-engines-alist  '(("jsp" . "\\.tag\\'")))
#+END_SRC

I also start up [[http://emmet.io/][Emmet]] for =web-mode=, any =sgml-mode= derivative, and
for =css-mode=...

I also have a few other =web-mode= tweaks in the =web-mode-hook= I
define.
#+BEGIN_SRC emacs-lisp
  (defun web-mode-hook ()
    "Hooks for Web mode."
    (setq web-mode-html-offset 2)
    (setq web-mode-css-offset 2)
    (setq web-mode-script-offset 2)
    (emmet-mode 1)
    (setq emmet-indentation 2)
    (toggle-truncate-lines t)
    (yas-minor-mode 1))
  (add-hook 'web-mode-hook 'web-mode-hook)
  (add-hook 'sgml-mode-hook 'ac-emmet-html-setup)
  (add-hook 'css-mode-hook 'ac-emmet-css-setup)
#+END_SRC

** Java
I don't do much Java in Emacs, that generally is the job of Eclipse
because of its super-intelligent support, integration with
everything, and ridiculous debugger capabilities... But when I
do... I only have two real tweaks to make:

#+BEGIN_SRC emacs-lisp
    ;; Java
    (add-hook 'java-mode-hook
              (lambda ()
                ;; Because these tend to be a lot longer than 80 width
                ;; and wrapping is ugly.
                (toggle-truncate-lines t)
                ;; I also prefer 2 spaces for indentation, not 4.
                (setq c-basic-offset 2)))
#+END_SRC

** JavaScript                                                      :Bindings:
#+BEGIN_SRC emacs-lisp :eval no
  ;; JavaScript
#+END_SRC
The support for JavaScript in Emacs is ridiculous. We have an entire
parser in the =js2-mode= package, which is very well-written.

#+BEGIN_SRC emacs-lisp :padline no
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
#+END_SRC

We also possibly have [[http://ternjs.net][Tern]], which gives us even *more* advanced
JavaScript IDE functionality like cross-file references, type
inference, and lots of other neat things... But it requires an
external executable. That means we need to check to see if it is set
up on this system. Either way, we will want to act accordingly:
#+BEGIN_SRC emacs-lisp
  (defvar *tern-exists* (exec-exists-p "tern")
    "Whether or not we can use Tern on this system. Set to \"t\"
    when we can, or \"nil\" when we can't.")
#+END_SRC

We will use the above for a number of checks to determine our strategy
for setting up our JavaScript functionality.

Of course, if Tern does not exist, we can install it with the
following (Assuming we have [[https://www.npmjs.com/][npm]]):
#+BEGIN_SRC sh :dir /sudo::
  npm install -g tern
#+END_SRC

Now, if Tern does not exist, we can also use js2's parser, for things
like =js2-refactor=, which allows for advanced automatic refactoring
such as renaming variables and extracting code blocks with intelligent
attention to scope (But it's only local to the current file as of the
time of writing):
#+BEGIN_SRC emacs-lisp
  (unless *tern-exists*
    (require 'js2-refactor)
    (local-set-key (kbd "s-r") 'js2r-rename-var))
#+END_SRC

There is also great =autocomplete= support with =ac-js2=... And that
allows for scope-intelligent jumping to definitions... I still want
=js2='s =autocomplete= for local variables because IMO it is superior
to Tern, but having two jumping bindings is redundant, so I disable
this one if we have Tern:
#+BEGIN_SRC emacs-lisp
  (add-hook 'js2-mode-hook
        (lambda ()
          (ac-js2-mode)
          (unless *tern-exists*
            (local-set-key (kbd "s-<f3>") #'ac-js2-jump-to-definition))))
#+END_SRC

Now, finally, the Tern configuration if we have it on this
system... It uses an Node.js process to give us essentially a
JavaScript IDE:
#+BEGIN_SRC emacs-lisp
  (when *tern-exists*
    (add-hook 'js2-mode-hook
              (lambda ()
                (setq-local ac-sources nil)
                (tern-mode)
                (tern-ac-setup)
                (local-set-key (kbd "s-r") 'tern-rename-variable)
                (local-set-key (kbd "s-<f3>") 'tern-find-definition))))
#+END_SRC

Also, lastly, I have [[http://jshint.com/][jshint]] loaded in case I feel like linting my
JavaScript beyond the things that =js2= pulls up.
#+BEGIN_SRC emacs-lisp
  (require 'flymake-jshint)
#+END_SRC

** Markdown mode
#+BEGIN_SRC emacs-lisp :eval no
  ;; Markdown
#+END_SRC

As of the time of writing, I don't think markdown mode has it set
automagically start for files with the =.md= file extension, so:
#+BEGIN_SRC emacs-lisp :padline no
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
#+END_SRC

** Python
I don't really write Python, but for the times I do, Jedi is neat:
#+BEGIN_SRC emacs-lisp
  ;; Jedi, for Python sweetness
  (add-hook 'python-mode-hook
            (lambda ()
              (jedi:ac-setup)
              (setq jedi:complete-on-dot t)))
#+END_SRC

** Ruby
#+BEGIN_SRC emacs-lisp :eval no
  ;; Ruby support
#+END_SRC

The default Ruby mode in Emacs is pretty good, partially because it
was [[http://www.slideshare.net/yukihiro_matz/how-emacs-changed-my-life][written by Matz himself.]] But there is still room for improvement:

First off, when =ruby-mode= is loaded, we also want to load
=robe-mode=, which allows for using an interactive Ruby instance for
completion...

#+BEGIN_SRC emacs-lisp :padline no
  (add-hook 'ruby-mode-hook 'robe-mode)
#+END_SRC

And for error checking, we use =flymake-ruby=:
#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook 'flymake-ruby-load)
#+END_SRC

There is an Enhanced Ruby Mode =enh-ruby=, though it is a bit finicky
currently, so I don't load it by default... But for the times I do
use it, I have defined this hook to configure it to use =robe-mode=
like normal Ruby mode and set up a bunch of =autocomplete= sources
for code assist:
#+BEGIN_SRC emacs-lisp
  (add-hook 'enh-ruby-mode-hook
            (lambda ()
              (robe-mode)
              (add-to-list 'ac-sources 'ac-source-robe)
              (add-to-list 'ac-sources 'ac-source-rsense-method)
              (add-to-list 'ac-sources 'ac-source-rsense-constant)))
#+END_SRC

** SQL
Emacs seems to fail at escaping backslashes in SQL files... So I have
slightly modified the syntax entry for the backslash character in SQL
files so it acts like a proper escape:
#+BEGIN_SRC emacs-lisp
  ;; SQL, fix buffer escaping
  (add-hook 'sql-mode-hook
            (lambda ()
              (modify-syntax-entry ?\\ "\\" sql-mode-syntax-table)))
#+END_SRC


* Utility
The following are things that are nice to have set up during normal
Emacs usage, but aren't for any type of task in particular.

** Evil
I find that one of the first things I do when I start Emacs recently
is start Evil... I may as well just put it in my config.

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

** Sauron                                                             :Hooks:
#+BEGIN_SRC emacs-lisp :eval no
  ;; Supremely useful monitor -- Sauron
#+END_SRC

The all-seeing eye, Sauron is quite useful, though I want to add some
functionality to the modeline with it, so I make higher-priority
messages set a variable: =sauron-alert=:

#+BEGIN_SRC emacs-lisp :padline no
  (add-hook 'sauron-event-added-functions
            (lambda (what priority message &optional event)
              (when (<= 4 priority)
                (setq sauron-alert t))))
#+END_SRC

The above means you can do something like the following:
#+BEGIN_SRC emacs-lisp :tangle no
  (when (boundp 'sauron-alert)
    "Code goes here for when Suaron sees something, yo.")
#+END_SRC

And of course, to set it back to nothingness:
#+BEGIN_SRC emacs-lisp :tangle no
  (makunbound 'sauron-alert)
#+END_SRC

I actually use this in the modeline and have the modeline use the
following function to generate a spooky eye that notifies me if Sauron
has seen something of interest with clickable text to bring me to the
Sauron buffer:
#+BEGIN_SRC emacs-lisp :tangle no
  (defun make-sauron-text ()
    "Creates a clickable Sauron text that switches to the Sauron
  buffer."
    (let ((map (make-keymap)))
      (define-key map [follow-link]
        (lambda (pos)
          (makunbound 'sauron-alert)
          (switch-to-buffer "*Sauron*")))
      (propertize " 0"
                  'keymap map
                  'face 'compilation-error
                  'help-echo "Sauron has seen something"
                  'pointer 'hand)))
#+END_SRC

And because I get notified of high-priority events normally with the
above, I have no need for Sauron to be its own frame:
#+BEGIN_SRC emacs-lisp
  (setq sauron-separate-frame nil)
#+END_SRC

** Expand Region                                                   :Bindings:
Expand Region is a very handy package for selecting arbitrary blocks
of text, be it code or whatever.

#+BEGIN_SRC emacs-lisp
  ;; Expand region
  (require 'expand-region)
  (global-set-key (kbd "s-SPC") 'er/expand-region)
  (global-set-key (kbd "s-S-SPC") 'er/contract-region)
#+END_SRC

** Multiple Cursors                                                :Bindings:
From the famous [[https://www.youtube.com/watch?v=jNa3axo40qM][Emacs Rocks video]] where it was introduced to the
masses, my configuration for this super-handy mode is as follows (Just
keybindings):

#+BEGIN_SRC emacs-lisp
  ;; Multiple-cursors
  (require 'multiple-cursors)
  (global-set-key (kbd "s-s") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-s-s") 'mc/mark-all-like-this)
  (global-set-key (kbd "M-s-s") 'mc/mark-next-symbol-like-this)
  (global-set-key (kbd "s-S") 'mc/mark-sgml-tag-pair)
#+END_SRC

** Projectile                                                      :Bindings:
Another really handy usability mode: Projectile!

I use Projectile with Helm to browse to files in the current (Or any)
project really fast:
#+BEGIN_SRC emacs-lisp
  ;; Projectile
  (require 'grizzl)
  (setq projectile-enable-caching t)
  (setq projectile-completion-system 'grizzl)
  (global-set-key (kbd "s-f") 'helm-projectile)
  (global-set-key (kbd "C-s-f") 'helm-projectile-all)
#+END_SRC

And since I want to enable Projectile everywhere, because jumping
between files fast is very handy:
#+BEGIN_SRC emacs-lisp
  ;; Enable projectile
  (projectile-global-mode)
#+END_SRC

** Avy                                                             :Bindings:
=Avy= is a [[http://emacsredux.com/blog/2015/07/19/ace-jump-mode-is-dead-long-live-avy/][re-imagining of ace-jump-mode]], which allows for very fast
jumping around a buffer.

It is very handy for navigation regardless of mode, so:
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "s-/") 'avy-goto-subword-1)
  (define-key global-map (kbd "s-?") 'avy-goto-char)
#+END_SRC

And since effective motions are essential to Evil:
#+BEGIN_SRC emacs-lisp
  (define-key evil-motion-state-map (kbd "p") #'avy-goto-subword-1)
  (define-key evil-motion-state-map (kbd "P") #'avy-goto-char)
#+END_SRC

** Show parenthesis mode
To my knowledge, there is not a single mode where this minor mode
isn't helpful or mildly amusing.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode)
#+END_SRC


* Org Mode                                                   :Bindings:Hooks:
Org mode deserves a section for itself because it is just that
important.

My Org mode setup includes support for spell checking, grammar
checking, tangling source files from Org mode, =auto-fill=, and syntax
coloring:

#+BEGIN_SRC emacs-lisp
  ;; Org mode
  (require 'org-install)
  (require 'ob-tangle)
  (add-hook
   'org-mode-hook
   (lambda ()
     (progn
       (flyspell-mode t)
       (auto-fill-mode t)
       (setq-default indent-tabs-mode nil)
       (setq org-src-fontify-natively t)
       (setq org-export-latex-listings 'minted)
       (local-set-key (kbd "C-c a") 'org-agenda)

       ;; LanguageTool setup
       (require 'langtool))))
#+END_SRC

Nothing too crazy, because most of Org's default configuration is
pretty sweet.

I /did/, however, have to add the =org-agenda= keybinding, since it
appears to not be bound by default.


* Variables
#+BEGIN_SRC emacs-lisp :eval no
  ;;;; Variables
#+END_SRC
There are some variables that I want to =setq= because I don't want
to have to customize them from their defaults.

** Lock Files
I really don't like Emacs lockfiles... They are annoying and mess up
an otherwise clean folder:
#+BEGIN_SRC emacs-lisp :padline no
  (setq create-lockfiles nil) ;; Nasty at times
#+END_SRC

** Tabs vs Spaces: The endless war
I am on the spaces side, because tab width screws up formatting
hardcore on things like Github if you want to do granular spacing and
their tabs are different from yours:
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil) ;; Screws up in other editors and Github
#+END_SRC

Come at me bro.

** Auto-backup config
Stolen from [[http://emacswiki.org/emacs/BackupDirectory][here]]... Very useful to have backup files not mess up the
current folder, and yet still exist:
#+BEGIN_SRC emacs-lisp
  ;; Auto-backups
  (setq backup-by-copying t      ; don't clobber symlinks
        backup-directory-alist
        '(("." . "~/.saves"))    ; don't litter my fs tree
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)       ; use versioned backups
  (setq backup-directory-alist `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
#+END_SRC


* Aliases
Aliases to replace one piece of functionality with another is
super-handy.

** Yes and No questions
Having to type "yes" is annoying when I just want to do something
simple... So, I alias =yes-or-no-p= to the single-keystroke
equivalent:

#+BEGIN_SRC emacs-lisp
  ;; Make boolean questions less annoying
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC


* Hooks                                                               :Hooks:
Hooks! A few small tweaks to suit my work style.

#+BEGIN_SRC emacs-lisp :eval no
  ;;;; Hooks
#+END_SRC

** Whitespace begone!
First of all, I dislike having messy whitespace in the files I am
working with, so I am sure to delete trailing whitespace whenever I
save a file... (This might become a problem sometime down the line,
but so far everything is good.)

#+BEGIN_SRC emacs-lisp :padline no
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC


* Bindings                                                         :Bindings:
#+BEGIN_SRC emacs-lisp :eval no
  ;;;; Non-specific bindings
#+END_SRC
This is a section for key and event bindings that don't fit anywhere
else.

** USR1 signal
When I am running Emacs, I don't always think about starting a server
of it, because I simply don't need it... But what happens if something
terrible happens to my desktop manager and Emacs is still intact? I
can't do a lot with it...

That is why I am going to make =kill -USR1 $(pidof emacs)= start an
Emacs server.

#+BEGIN_SRC emacs-lisp :padline no
  (define-key special-event-map (kbd "<sigusr1>") 'server-start)
#+END_SRC


* Metadata                                                         :noexport:
#  LocalWords:  elisp LocalWords Flymake padline modeline hidestars
#  LocalWords:  config http TLS tls alist Matz JSPs langtool Avy JSP
#  LocalWords:  Spifftastic Autocomplete NOX js executables args USR
